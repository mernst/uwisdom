= Wisdom about Java
:toc:
:toc-placement: manual

toc::[]


== JIT

To disable the JIT, run Java with the  -Djava.compiler=DISABLED  option.

To make Throwable.printStackTrace() produce file names and line numbers in
Java (under Solaris, using Sun's JVM), disable the JIT that compiles away
source code information:
```
  setenv JAVA_COMPILER NONE
```
Of course, the code must have been compiled with debugging enabled (-g
switch to compiler)!

The Java bytecode verifier gave me
```
  Exception in thread "main" java.lang.VerifyError: (class: Hello, method: main signature: ([Ljava/lang/String;)V) Incompatible object argument for function call
```
when the problem was that I had used "invokevirtual" where I should have
used "invokestatic".


== JUnit

JUnit:  helps in writing Java test suites.  www.junit.org
To run JUnit:
```
  java junit.textui.TestRunner ps1.PublicTest
```

How do I launch a debugger (e.g. jdb) when a JUnit test fails?
Start the TestRunner under the debugger and configure the debugger so that
it catches the junit.framework.AssertionFailedError.  Notice that this will
only launch the debugger when an expected failure occurs.
For example:
----
  java -cp whatever:/path/to/junit.jar junit.textui.TestRunner MyTestClass
  catch junit.framework.AssertionFailedError
  run
----

Here are Emacs commands for replacing JUnit assertions with Hamcrest
versions that produce more readable output.  Even though the Hamcrest code
isn't always easier to read, this can be worthwhile.
----
(tags-query-replace "assertFalse(\\(\".*\",\\)
\\([ 	]*\\) \\(.*\\)\\.equals(\\(.*\\)));
" "assertThat(\\1
\\2\\3, not(\\4));
")
(tags-query-replace "assertTrue(!\\(.*\\)\\.equals(\\(.*\\)));" "assertThat(\\1, not(\\2));")
(tags-query-replace "assertFalse(\\([^\"].*\\)\\.equals(\\(.*\\)));" "assertThat(\\1, not(\\2));")
(tags-query-replace "assertTrue(\\([^\"].*\\)\\.equals(\\(.*\\)));" "assertEquals(\\1, \\2);")
(tags-query-replace "assertTrue(\\([^\"].*\\) == \\(.*\\));" "assertEquals(\\1, \\2);")
(tags-query-replace "assertTrue(\\(\".*\"\\), !\\(.*\\)\\.equals(\\(.*\\)));" "assertThat(\\1, \\2, not(\\3));")
(tags-query-replace "assertTrue\\( ?\\)(\\(\".*\"\\),\\( \\|
 *\\)!\\(.*\\)\\.equals ?(\\(.*\\)));" "assertThat\\1(\\2,\\3\\4, not(\\5));")
(tags-query-replace "assertTrue\\( ?\\)(\\(\".*\"\\),\\( \\|
 *\\)\\(.*\\)\\.equals ?(\\(.*\\)));" "assertEquals\\1(\\2,\\3\\4, \\5);")
(tags-query-replace "assertTrue\\( ?\\)(\\(\".*\"\\),\\( \\|
 *\\)\\(.*\\) == \\(.*\\));" "assertEquals\\1(\\2,\\3\\4, \\5);")
----


== Debugging

Graphical Java debugger:  jswat (http://www.bluemarsh.com/java/jswat/).
To run it:
```
  java com.bluemarsh.jswat.Main
```

kill -QUIT _pid_ causes Java to do a traceback from each thread and keep going.
If java is running in a shell, you can also normally use ctrl-\ as well.

To debug a Java infinite loop, send SIGQUIT (kill -3) to get a stack trace
(but Java process keeps running).

To eliminate nondeterminism from a (sequential, non-concurrent) Java program:
//nobreak

 * Use `LinkedHashMap` and `LinkedHashSet` rather than `HashMap` and `HashSet`.
 * Override hashCode(), so that your program does not use Object.hashCode() which is nondeterministic (it depends on when the garbage collector runs). Also don't instantiate the Object class, as in new Object(); instead, use some class that overrides hashCode().
 * Mitigate other sources of nondeterminism, such as always calling `Arrays.sort` on the result of `File.listFiles`.

JVM segfaults:
When the VM crashes, it generates a log file of the active frames.
To get line numbers too, make the VM create a core dump, then use jstack:
```
  jstack `which java` core.<pid>
```


== Profiling

For notes about Java garbage collection and the heap, see wiki page JavaHeap.

For notes about Java profiling, see wiki page JavaTools.

Some ways to profile/understand java memory use
  The Runtime class has methods that will return the total amount of
  memory used.  These don't seem to be terribly accurate.
  There is a heap/CPU profiler that seems to work pretty well.
  look at:      
    http://java.sun.com/j2se/1.4.2/docs/guide/jvmpi/jvmpi.html#hprof
  By default, it gives only heap usage profiles; for CPU profiling, use:
    java -Xrunhprof:cpu=samples

Java timing information via System.currentTimeMillis() is only accurate
to milliseconds.  I couldn't find anything more precise.  Nor anything
that works with CPU time rather than wallclock time.



== Generics

Official (JLS) terminology for Java generics (parametric polymorphism):

 * The formal type parameter is called a "type parameter".
   The parameter is
   also, equivalently, called a "type variable".  But "type parameter"
   tends to be used when speaking of the declaration and "type variable"
   tends to be used when speaking of its uses in the body.
   (For a method/constructor, it's called the "formal type parameter";
   JLS3, sec 8.4.4.)
   The "type parameter section" is delimited by angle brackets and
   declares the type variables.  (JLS3, sec 8.1.2).
 * The actual type parameter is called a "type argument".
 * A "parameterized type" is a type that has type arguments/parameters.
 * A class is generic if it declares one or more type variables (JLS3, sec 8.1.2).
   JLS only uses "generic" to refer to class *declarations*, not
   classes.  "A generic class declaration defines a set of parameterized
   types, one for each possible invocation of the type parameter section."

.Terminology for generics/parametrc polymorphism in Java, from _Effective Java_, second editon, page 115.
|====
| Parameterized type      | `List<String>` |
| Actual type parameter   | `String` |
| Generic type            | `List<E>` |
| Formal type parameter   | `E` |
| Unbounded wildcard type | `List<?>` |
| Raw type                | `List` |
| Bounded type parameter  | `<E extends Number>` |
| Recursive type bound    | `<T extends Comparable<T>>` |
| Bounded wildcard type   | `List<? extends Number>` |
| Generic method static   | `<E> List<E> asList(E[] a)` |
| Type token              | `String.class` |
|====
The first part ("`List`") of a parameterized type name is called the
class name.
The first part ("`List`") of a generic type name is called:  (??? no
good name, Alex Buckley suggested that it also be "class name", but that
isn't quite right).
They don't have a name for a use of type parameter/variable, to distinguish
from the declaration.
(The _Effective Java_ terminology differs from that used in the JLS.)


== javac


To pass the -Xlint argument to javac when running from Ant, do:
```
      <compilerarg value="-Xlint"/>
```


javac is a java class that runs on a JVM, and you can pass parameters to
that JVM using the -J argument.  In particular, you can pass -J-Xmx1024M to
give the JVM a gigabyte of memory for the heap.

The command
----
  javac -jar myjar.jar
----
ignores the CLASSPATH environment variable, so you may need to pass it
explicitly: 
----
  javac -jar myjar.jar -cp ${CLASSPATH}
----

To limit/increase the number of errors that javac will print use, -Xmaxerrs N

If javac says
```
  warning: unmappable character for encoding UTF8
```
then change the Ant task:
```
  <javac encoding="8859_1" ...
```
or the command line:
```
  javac -encoding 8859_1 ...
```

There are two ways to disable javac warnings of the form
```
  ... uses internal proprietary API that may be removed in a future release
  ... is internal proprietary API and may be removed in a future release
```
* Approach #1 is to run
```
  javac -XDignore.symbol.file ...
```
flag which will compile your program against Oracle's/Sun's internal rt.jar
rather than the public-facing symbol file `ct.sym`.
* Approach 2 has two variants
** Approach #2a is to run
```
  javac -XDenableSunApiLintControl -Xlint:-sunapi ...
```
This still issues a "note" but not a warning.
** Approach #2b is to suppress the warning and the note by writing
```
  @SuppressWarnings("sunapi")
```
in the source code, but this still requires you to run javac as follows:
```
  javac -XDenableSunApiLintControl ...
```



== javadoc

To find Javadoc comments that use "<" or ">" but shouldn't:
----
search -i -n '^ *\*.*(<[^/]|>)'
----
and then, in the result:
----
(query-replace-regexp "</?\\(li\\|p\\|b\\|tt\\|pre\\|i\\|a\\|a [^<>]*\\|blockquote\\|ul\\|code\\|em\\|strong\\|br\\)>" "" nil (if (and transient-mark-mode mark-active) (region-beginning)) (if (and transient-mark-mode mark-active) (region-end)))
----
and finally look for instances of `[<>]`.

How to quote less than and greater than (angle brackets), such as for generics, in Javadoc comments:
```
 Equation: {@literal i > j}
 Inline code: {@code getThat()}
 Multi line code:
   <pre>{@code
   ...
   }</pre>
 (what if the multi-line code contains curly braces??)
```
To quote/escape the @ (at-sign) symbol in Javadoc, use {@literal @} or &#064;

To avoid doclint messages about missing Javadoc tags, such as "no @param for someArg":
----
-Xdoclint:all,-missing
----
This only works with Javadoc 8 and later.



== Everything else


JDK 1.4 is still distributed, but at an obscure URL:
 http://java.sun.com/javase/downloads/jdk/142/
Or, at http://java.sun.com/javase/downloads/, click on "Previous Releases".

To get a copy of the JDK 7 source:
  hg clone http://hg.openjdk.java.net/jdk7/jdk7/jdk

Java 1.4 ("J2SE 1.4") was released in February 2002. +
Java 5 ("J2SE 5.0") was released in September 2004. +
Java 6 ("J2SE 6") was released in December 2006 (public beta by February 2006). +
Java 7 ("J2SE 7") release date is September 2011.  See:
  http://openjdk.java.net/projects/jdk7/milestones/
  http://openjdk.java.net/projects/jdk7/calendar/

Major version number for the Java class file format (JVM version number):
----
  J2SE 9.0 = 53 (0x35 hex)    [as of 5/7/2015, goal is September 2016]
  J2SE 8.0 = 52 (0x34 hex)    [released March 2014]
  J2SE 7.0 = 51 (0x33 hex)    [released July 2011]
  J2SE 6.0 = 50 (0x32 hex)    [released December 2006]
  J2SE 5.0 = 49 (0x31 hex)    [released September 2004]
  JDK 1.4 = 48 (0x30 hex)
  JDK 1.3 = 47 (0x2F hex)
  JDK 1.2 = 46 (0x2E hex)
  JDK 1.1 = 45 (0x2D hex)
----

To pretty-print or indent a Java program, do "java JavaPP filename.java".
Or, use my shell script "javapp file1.java file2.java file3.java ...",
which overwrites the original file.

To run Java with a maximum of 900 Mbytes of memory (default 64 Mbytes):
```
  java -Xmx900m ...
```

java.lang.Class.forName requires different versions of the string
representation of a class as its argument depending on whether you want to
get back an array or not.  For instance, these are legal:
```
  Class.forName("[Ljava.lang.Integer;")
  Class.forName("java.lang.Integer")
```
but this is not:
```
  Class.forName("Ljava.lang.Integer;")
```

Java file reading usually permits either \n or \r\n to end a line.
However, if the first character of a file is \n, Java file reading seems to
produce blank lines for each subsequent \r\n.

Java 1.5 meta-data facility (annotations) (JSR 175) implements meta-data tags:
http://www.jcp.org/en/jsr/detail?id=175

JWhich tells where on the classpath a Java file is found.
I have a "jwhich" shell script wrapped around this.

In Java, "null instanceof Class" returns false for any Class.

Canonical use of package java.util.regex.* for Java regular expressions:
```
  Pattern p = Pattern.compile("a*b");
  Matcher m = p.matcher("aaaaab");
  boolean b = m.matches();              // exact match (whole target string)
  boolean b = m.lookingAt();            // subsequence starting at beginning
  boolean b = m.find();                 // subsequence
  String g = m.group(2);                // text captured by the given group
```
or, less frequently,
```
  boolean b = Pattern.matches("a*b", "aaaaab");
```

Java issues (bug reports, RFEs, etc.):  http://bugs.sun.com/bugdatabase/

LVTT - Local Variable Type Table
Errors can occur when instrumenting with BCEL.  One error is:
----
     LVTT entry for 'list' in class file daikon/dcomp/Test does not match any LVT entry
----
The easiest solution I've found so far is to simply remove these tables.
They are only used by debuggers and when instrumenting, that is seldom
an issue.  utilMDE/BCELUtil has a method (remove_local_variable_type_tables)
that does this for a method.

Java nested classes are of two varieties:  static and inner.

To determine which class files require a given JDK version (or earlier):
```
  find | xargs java ClassFileVersion -min 1.6 | grep -v "is neither a"
```
This is good for debugging errors of the form
  Exception in thread "main" java.lang.UnsupportedClassVersionError: Bad version number in .class file
that give no indication of what .class file was problematic.

To execute a shell command in Java:
```
Runtime.getRuntime().exec(String [] cmdarray);
```

In Java, File.getName() returns the basename:  no directory components, but
does include the filename extension.

After starting jdb, do something like
  stop in utilMDE.JWhich.main
  run
lest when you issue the "run" command the application continues to termination.

In Java, to iterate over the elements of a HashMap, do:
```
    for (Map.Entry entry : hash_map.entrySet()) {
      ... entry.getKey() ...
      ... entry.getValue() ...
    }
```
To iterate over the values:
```
    for (ValType value : hash_map.values()) {
      ...
    }
```

A disadvantage of the new-style for loop is that there is no name for the
iterator, so there is no way to access important information such as the
current index or other information that a specialized iterator may make
available.
 +
  A way to get around this is for a single object to implement both
Iterator and Iterable.  The Iterable.iterator() method would just return
"this", and within the foor loop body, the client can refer to the iterable
to obtain the desired information.
 +
  The problem with this design is that it assumes that there is exactly one
iterator for the object at a time.  Clients may expect that it is possible
to have multiple iterators over a given Iterable, and thus may expect that
each call to Iterable.iterator returns a fresh iterator that shares no
state with other iterators.  But. clients really shouldn't assume this in
the absence of documentation so stating, and if something is both an
Iterable and an Iterator, it's intuitive (and should be documented) that
iterator() would return itself.


Notes about Java instrumentation:
Instrumenting annotation classes by adding parameters will cause
annotation to not be handled correctly.
Methods in an Annotation class can not have any parameters.  When you
add the DCompMarker parameter to those methods, AnnotationType will
throw an IllegalArgumentException.  This (unfortunately) does not
show up directly, but only results in the retention policy being set
to its Class (the default) rather than to what the user wanted (eg,
RUNTIME).  This manifested itself in our case by having the Option
annotations disappear (thus making it impossible to parse command line
options).  I think it should be safe to simply not add arguments to
Annotation methods.  Since these 'methods' aren't executable anyway.

replacing rt.jar
It is possible to override/replace the system rt.jar using the
-Xbootclasspath switch to java.  The documentation says that doing so
violates Sun's license agreement.  It is not clear why this is true.

You can turn off the verifier on any VM with -Xverify:none.  Derek discovered
this like so:
----
$ strings `which java` | grep -i verif
-Xverify:all
-verify
-verifyremote
-Xverify:remote
-noverify
-Xverify:none
----

Jardiff takes two jar files and outputs all the public API changes.
http://www.osjava.org/jardiff/

To read a file line by line from Java use:
----
    BufferedReader br = new BufferedReader (new FileReader (filename));
    for (String line = br.readLine(); line != null; line = br.readLine())
        ;
----
Unfortunately, this will throw IOExceptions.  I don't know of any standard
Java class that does not.
 +
Or, to read lines with line numbers use:
----
    LineNumberReader lr = new LineNumberReader (new FileReader (filename));
    for (String line = lr.readLine(); line != null; line = lr.readLine())
        lr.getLineNumber();
----
Or, you can use utilMDE.EntryReader which supports the new-style for loop.

Don't use Runtime.exec(); instead, use ProcessBuilder.start().

"Could not reserve enough space for object heap" means that the
"-Xmx" argument on the java command line was too large.

`JAVA_HOME` is the JDK install directory, e.g., ...jdk1.7.0 .
`java.home` is the JRE install directory, e.g., ...jre .
(See http://javahowto.blogspot.com/2006/05/javahome-vs-javahome.html .)



//  LocalWords:  decompile jdecomp jtrek JIT Djava Throwable printStackTrace Ljava toc java ps1 jdb TestRunner cp MyTestClass
//  LocalWords:  Solaris setenv invokevirtual invokestatic JavaPP filename javapp
//  LocalWords:  javadoc cd utilMDE subpackages dirname uniq perl HashMap itor Xmx
//  LocalWords:  entrySet getKey getValue ValType Mbytes forName JUnit ps jswat
//  LocalWords:  PublicTest ProfileViewer javac JSR JWhich classpath jwhich pid
//  LocalWords:  instanceof traceback ctrl aaaaab boolean lookingAt unjar jdk src
//  LocalWords:  RFEs LVTT BCEL daikon LVT BCELUtil
